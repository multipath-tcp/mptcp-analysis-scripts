#! /usr/bin/python
# -*- coding: utf-8 -*-
#
#  Copyright 2015 Quentin De Coninck
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
#  MA 02110-1301, USA.
#
#  To install on this machine: matplotlib, numpy

from __future__ import print_function

import argparse
import matplotlib
# Do not use any X11 backend
matplotlib.use('Agg')
matplotlib.rcParams['pdf.fonttype'] = 42
matplotlib.rcParams['ps.fonttype'] = 42
import matplotlib.pyplot as plt
import numpy as np
import os
import sys

# Add root directory in Python path and be at the root
ROOT_DIR = os.path.abspath(os.path.join(".", os.pardir))
os.chdir(ROOT_DIR)
sys.path.append(ROOT_DIR)

import common as co
import common_graph as cog
import mptcp
import tcp

##################################################
##                  ARGUMENTS                   ##
##################################################

parser = argparse.ArgumentParser(
    description="Summarize stat files generated by analyze")
parser.add_argument("-s",
                    "--stat", help="directory where the stat files are stored", default=co.DEF_STAT_DIR + '_' + co.DEF_IFACE)
parser.add_argument('-S',
                    "--sums", help="directory where the summary graphs will be stored", default=co.DEF_SUMS_DIR + '_' + co.DEF_IFACE)
parser.add_argument("-d",
                    "--dirs", help="list of directories to aggregate", nargs="+")

args = parser.parse_args()
stat_dir_exp = os.path.abspath(os.path.join(ROOT_DIR, args.stat))
sums_dir_exp = os.path.abspath(os.path.join(ROOT_DIR, args.sums))
co.check_directory_exists(sums_dir_exp)

##################################################
##                 GET THE DATA                 ##
##################################################

connections = cog.fetch_valid_data(stat_dir_exp, args)
multiflow_connections, singleflow_connections = cog.get_multiflow_connections(connections)

##################################################
##               PLOTTING RESULTS               ##
##################################################

nb_conns = 0
nb_subflows = 0
nb_unused = 0
nb_addi_sf = 0
nb_unused_addi_sf = 0
nb_unused_rst = 0
nb_unused_addi_rst = 0
nb_unused_addi_bak = 0
nb_after_duration = 0
nb_after_duration_bursts = 0
better_rtt = 0
better_rtt_conn_less_1k = 0
better_rtt_conn_less_5k = 0
better_rtt_conn_less_10k = 0

for fname, conns in multiflow_connections.iteritems():
    for conn_id, conn in conns.iteritems():
        nb_conns += 1
        for flow_id, flow in conn.flows.iteritems():
            nb_subflows += 1
            if not flow_id == 0:
                nb_addi_sf += 1

            if flow.attr[co.C2S].get(co.BYTES, 0) == 0 and flow.attr[co.S2C].get(co.BYTES, 0) == 0:
                nb_unused += 1
                if not flow_id == 0:
                    nb_unused_addi_sf += 1

                if flow.attr.get(co.BACKUP, False):
                    nb_unused_addi_bak += 1

                if not flow.attr[co.S2D].get(co.NB_RST, 0) == 0 or not flow.attr[co.D2S].get(co.NB_RST, 0) == 0:
                    nb_unused_rst += 1
                    # Short
                    if not flow_id == 0 and flow.attr[co.DURATION] < 1.0:
                        nb_unused_addi_rst += 1

                if co.TIME_FIRST_ACK in flow.attr[co.S2D] and flow.attr[co.S2D][co.TIME_FIRST_ACK] + flow.attr[co.START].total_seconds() >= conn.attr[co.START].total_seconds() + float(conn.attr[co.DURATION]):
                    nb_after_duration += 1

                after_duration_burst = False
                if not flow_id == 0 and co.TIME_FIRST_ACK in flow.attr[co.S2D] and co.BURSTS in conn.attr[co.D2S] and co.BURSTS in conn.attr[co.S2D]:
                    if len(conn.attr[co.D2S][co.BURSTS]) > 0:
                        if flow.attr[co.S2D][co.TIME_FIRST_ACK] + flow.attr[co.START].total_seconds() >= conn.attr[co.D2S][co.BURSTS][-1][4] + conn.attr[co.D2S][co.BURSTS][-1][3]:
                            after_duration_burst = True
                    if len(conn.attr[co.S2D][co.BURSTS]) > 0:
                        if flow.attr[co.S2D][co.TIME_FIRST_ACK] + flow.attr[co.START].total_seconds() >= conn.attr[co.S2D][co.BURSTS][-1][4] + conn.attr[co.S2D][co.BURSTS][-1][3]:
                            after_duration_burst = True

                    if len(conn.attr[co.D2S][co.BURSTS]) == 0 and len(conn.attr[co.S2D][co.BURSTS]) == 0:
                        after_duration_burst = True

                if after_duration_burst:
                    nb_after_duration_bursts += 1

                # Find the other active subflows (if there are) and compare its RTT
                if co.RTT_AVG in flow.attr[co.D2S] and not flow_id == 0:
                    other_flows = []
                    best = True
                    for other_flow_id, other_flow_cand in conn.flows.iteritems():
                        if not other_flow_id == flow_id and co.TIME_FIRST_ACK in flow.attr[co.S2D]:
                            if co.START in other_flow_cand and flow.attr[co.S2D][co.TIME_FIRST_ACK] + flow.attr[co.START].total_seconds() >= other_flow_cand.attr[co.START].total_seconds():
                                if flow.attr[co.S2D][co.TIME_FIRST_ACK] + flow.attr[co.START].total_seconds() <= other_flow_cand.attr[co.START].total_seconds() + other_flow_cand.attr.get(co.DURATION, 0):
                                    other_flows.append(other_flow_cand)
                                    if co.RTT_AVG in other_flow_cand.attr[co.D2S] and other_flow_cand.attr[co.D2S][co.RTT_AVG] < flow.attr[co.D2S][co.RTT_AVG]:
                                        best = False
                                        break

                    if best and len(other_flows) > 0:
                        better_rtt += 1
                        conn_bytes = 0
                        for direction in co.DIRECTIONS:
                            conn_bytes += conn.attr[direction][co.BYTES_MPTCPTRACE]

                        if conn_bytes <= 10000:
                            better_rtt_conn_less_10k += 1
                            if conn_bytes <= 5000:
                                better_rtt_conn_less_5k += 1
                                if conn_bytes <= 1000:
                                    better_rtt_conn_less_1k += 1

print("NB CONNS", nb_conns)
print("NB SUBFLOWS", nb_subflows)
print("NB UNUSED", nb_unused)
print("NB ADDI SF", nb_addi_sf)
print("NB UNUSED ADDI SF", nb_unused_addi_sf)
print("NB UNUSED RST", nb_unused_rst)
print("NB UNUSED ADDI RST", nb_unused_addi_rst)
print("NB UNUSED ADDI BAK", nb_unused_addi_bak)
print("NB AFTER DURATION", nb_after_duration)
print("NB AFTER DURATION BURSTS", nb_after_duration_bursts)
print("BETTER RTT", better_rtt)
print("BETTER RTT CONN LESS 1K", better_rtt_conn_less_1k)
print("BETTER RTT CONN LESS 5K", better_rtt_conn_less_5k)
print("BETTER RTT CONN LESS 10K", better_rtt_conn_less_10k)
